// Good Code: Using Blocks for Asynchronous Operations

@interface MyObject : NSObject

- (void)performLongRunningTaskWithCompletion:(void (^)(BOOL success, NSError *error))completion;

@end

@implementation MyObject

- (void)performLongRunningTaskWithCompletion:(void (^)(BOOL success, NSError *error))completion {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Simulate long-running task
        sleep(2); 
        BOOL success = arc4random_uniform(2) == 0; // Random success/failure
        NSError *error = success ? nil : [NSError errorWithDomain:@"MyDomain" code:1 userInfo:nil];
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(success, error);
        });
    });
}

@end


// Bad Code: Improper Error Handling and Synchronous Operation

@interface MyBadObject : NSObject

- (BOOL)performLongRunningTask;

@end

@implementation MyBadObject

- (BOOL)performLongRunningTask {
    // Simulate long-running task (blocking the main thread!)
    sleep(2);
    return arc4random_uniform(2) == 0;
}

@end

//Example usage (Good code)
MyObject *obj = [[MyObject alloc] init];
[obj performLongRunningTaskWithCompletion:^(BOOL success, NSError *error) {
    if (success) {
        NSLog(@"Task completed successfully!");
    } else {
        NSLog(@"Task failed: %@", error);
    }
}];


// Example usage (Bad Code) - Avoid this pattern
MyBadObject *badObj = [[MyBadObject alloc] init];
BOOL success = [badObj performLongRunningTask]; // Blocks the main thread!
if (success) {
    NSLog(@"Task completed successfully (bad code)!");
} else {
    NSLog(@"Task failed (bad code)!");
}

