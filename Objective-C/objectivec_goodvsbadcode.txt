// Good Code: Using Blocks for Asynchronous Operations

#import <Foundation/Foundation.h>

@interface MyObject : NSObject

- (void)performLongOperationWithCompletion:(void (^)(BOOL success))completion;

@end

@implementation MyObject

- (void)performLongOperationWithCompletion:(void (^)(BOOL success))completion {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // Simulate a long-running operation
        sleep(2); 
        BOOL success = arc4random_uniform(2) == 0; // Random success/failure
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(success);
        });
    });
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyObject *obj = [[MyObject alloc] init];
        [obj performLongOperationWithCompletion:^(BOOL success) {
            if (success) {
                NSLog(@"Operation succeeded!");
            } else {
                NSLog(@"Operation failed!");
            }
        }];
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]]; // Keep the app running to see results
    }
    return 0;
}


// Bad Code: Improper Error Handling and Memory Management

#import <Foundation/Foundation.h>

@interface MyObject : NSObject

- (void)performOperation;

@end

@implementation MyObject

- (void)performOperation {
    // No error handling
    // Potential memory leaks if file operations fail
    FILE *file = fopen("/path/to/file", "r"); 
    if (file) {
        // ... process the file ...
        fclose(file); 
    }

}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyObject *obj = [[MyObject alloc] init];
        [obj performOperation];
    }
    return 0;
}
